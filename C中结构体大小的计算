C中结构体大小的计算

原创： 华清远见苗老师  华清远见北京中心  9月29日

最近研究了一下c语言中结构体大小的计算，根据自己的理解以及参考网上的资料，
想做一点总结。
   先介绍一个相关的概念——偏移量。偏移量指的是结构体变量中成员的地址和结构体
变量地址的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。
由于存储变量时地址对齐的要求，编译器在编译程序时会遵循两条原则：
一、结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍）
二、结构体大小必须是所有成员大小的整数倍。

这是一种说法，还有一种说法：
 
结构体默认的字节对齐一般满足三个准则：
1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
 2) 结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，
如有需要编译器会在成员之间加上填充字节（internal adding）；
3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末
一个成员之后加上填充字节。
我自己写了三个结构体测试了一下，代码如下：



输出结果是：
12
8
20
 
先看第一个结构体，第一个成员a的偏移量为0。第二个成员b的偏移量是第一个成员的偏移量加上第一个成员的大小（0+4）,其值为4；第三个成员c的偏移量是第二个成员的偏移量加上第二个成员的大小（4+1）,其值为5。上面的例子中前两个成员的偏移量都满足要求，但第三个成员的偏移量为5，并不是自身(int)大小的整数倍。编译器在处理时会在第二个成员后面补上3个空字节，使得第三个成员的偏移量变成8。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。偏移量8加上最后一个成员c自身的大小，即为9，9不能被最宽基本类型成员大小整除，所以这里编译器会在最后补齐3个字节，得出12。
　　至于第二个结构体，大小等于最后一个成员的偏移量加上其大小，上面的例子中计算出来的大小为8，满足要求。
       按照上述的计算规则，结构体一和结构体二都可以计算出与输出一致的结果，可是结构体三有点不明白。
 
    偏移量              填充字节                    成员自身大小
           0                                                        4
           4                                                        1
           5                      1                                2
           8                                                        8
           16                                                      4 
最后一个成员的偏移量加上自身大小，得出20，20不能整除最宽成员偏移量大小,double比较特殊， 分拆成两部分，每部分4个字节。最后整除时，除以4就可以了！

阅读 902
写留言
