转
https://blog.csdn.net/wordwarwordwar/article/details/78509445
彻底搞懂状态机（一段式、两段式、三段式）
2017年11月11日 23:16:10 长弓的坚持 阅读数：11078更多
个人分类： FPGA开发
实例：FSM实现10010串的检测



状态转移图：初始状态S0，a = 0,z = 0.如果检测到1，跳转到S1。

            下一状态S1，a = 1,z = 0.如果检测到0，跳转到S2。
            下一状态S2，a = 0,z = 0.如果检测到0，跳转到S3。
            下一状态S3，a = 0,z = 0.如果检测到1，跳转到S4。
            下一状态S4，a = 1,z = 0.如果检测到0，跳转到S5。
            下一状态S5，a = 0,z = 1.如果检测到1，跳转到S1；如果检测到0，跳转到S3（因为之前S4已经是1，S5是0，若再检测到0，就是100，因此跳转到S4）。



程序中将一段式（one_fsm）、两段式（two_fsm）、三段式（three_fsm）以及对应的仿真文件（XXX_tb）包含在了一个工程中。要单独运行、仿真每一种方式，只需将他们（one_fsm.v、two_fsm.v、three_fsm.v）分别设为顶层文件(选中右击，然后选择Set as Top-Level Entity)，然后在仿真设置里面选择对应的仿真文件即可。见下图：



 


补充：（转）PART1

1、好的状态机标准

好的状态机的标准很多，最重要的几个方面如下：

第一，状态机要安全，是指FSM不会进入死循环，特别是不会进入非预知的状态，而且由于某些扰动进入非设计状态，也能很快的恢复到正常的状态循环中来。这里面有两层含义：其一要求该FSM的综合实现结果无毛刺等异常扰动；其二要求FSM要完备，即使受到异常扰动进入非设计状态，也能很快恢复到正常状态。

第二，状态机的设计要满足设计的面积和速度的要求。

第三，状态机的设计要清晰易懂、易维护。



2、状态机描述方法

状态机描述时关键是要描述清楚几个状态机的要素，即如何进行状态转移，每个状态的输出是什么，状态转移的条件等。具体描述时方法各种各样，最常见的有三种描述方式：

（1）一段式：整个状态机写到一个always模块里面，在该模块中既描述状态转移，又描述状态的输入和输出；

（2）二段式：用两个always模块来描述状态机，其中一个always模块采用同步时序描述状态转移；另一个模块采用组合逻辑判断状态转移条件，描述状态转移规律以及输出；

（3）三段式：在两个always模块描述方法基础上，使用三个always模块，一个always模块采用同步时序描述状态转移，一个always采用组合逻辑判断状态转移条件，描述状态转移规律，另一个always模块描述状态输出(可以用组合电路输出，也可以时序电路输出)。



一般而言,推荐的FSM 描述方法是后两种。这是因为：FSM和其他设计一样，最好使用同步时序方式设计，以提高设计的稳定性，消除毛刺。状态机实现后，一般来说，状态转移部分是同步时序电路而状态的转移条件的判断是组合逻辑。



第二种描述方法同第一种描述方法相比，将同步时序和组合逻辑分别放到不同的always模块中实现，这样做的好处不仅仅是便于阅读、理解、维护，更重要的是利于综合器优化代码，利于用户添加合适的时序约束条件，利于布局布线器实现设计。

在第二种方式的描述中，描述当前状态的输出用组合逻辑实现，组合逻辑很容易产生毛刺，而且不利于约束，不利于综合器和布局布线器实现高性能的设计。

第三种描述方式与第二种相比，关键在于根据状态转移规律，在上一状态根据输入条件判断出当前状态的输出，从而在不插入额外时钟节拍的前提下，实现了寄存器输出。



PART2

时序电路的状态是一个状态变量集合，这些状态变量在任意时刻的值都包含了为确定电路的未来行为而必需考虑的所有历史信息。

状态机采用VerilogHDL语言编码，建议分为三个always段完成。



三段式建模描述FSM的状态机输出时，只需指定case敏感表为次态寄存器，然后直接在每个次态的case分支中描述该状态的输出即可，不用考虑状态转移条件。

三段式描述方法虽然代码结构复杂了一些，但是换来的优势是：使FSM做到了同步寄存器输出，消除了组合逻辑输出的不稳定与毛刺的隐患，而且更利于时序路径分组，一般来说在FPGA/CPLD等可编程逻辑器件上的综合与布局布线效果更佳。

示列模板如下：

//第一个进程，同步时序always模块，格式化描述次态寄存器迁移到现态寄存器

always @ (posedge clk or negedge rst_n) //异步复位

if(!rst_n)

current_state <= IDLE;

else

current_state <= next_state; //注意，使用的是非阻塞赋值

//第二个进程，组合逻辑always模块，描述状态转移条件判断

always @ (current_state) //电平触发

begin

next_state = x; //要初始化，使得系统复位后能进入正确的状态

case(current_state)

S1: if(...)

next_state = S2; //阻塞赋值

...

endcase

end

//第三个进程，同步时序always模块，格式化描述次态寄存器输出

always @ (posedge clk or negedge rst_n)

...//初始化

case(next_state)

S1:

out1 <= 1'b1; //注意是非阻塞逻辑

S2:

out2 <= 1'b1;

default:... //default的作用是免除综合工具综合出锁存器

endcase

end

两段式有限状态机与三段式有限状态机的区别

FSM将时序部分（状态转移部分）和组合部分（判断状态转移条件和产生输出）分开，写为两个always语句，即为两段式有限状态机。
将组合部分中的判断状态转移条件和产生输入再分开写，则为三段式有限状态机。
区别：
二段式在组合逻辑特别复杂时适用，但要注意需在后面加一个触发器以消除组合逻辑对输出产生的毛刺。三段式没有这个问题，由于第三个always会生成触发器。
设计时注意方面：
1.编码原则

binary和gray-code适用于触发器资源较少，组合电路资源丰富的情况（CPLD），对于FPGA，适用one-hot code。这样不但充分利用FPGA丰富的触发器资源，还因为只需比较一个bit，速度快，组合电路简单。

2.FSM初始化问题：
GSR(Gobal Set/Reset)只是在加电时清零所有的reg和片内ram，并不保证FSM能进入初始化状态，要利用GSR，方案是适用one-hot code with zero idle，即初始状态编码为全零。已可以适用异步复位rst
3.FSM输出可以适用task
4FSM中的case最好加上default，默认态可以设为初始态
5.尤其注意：
第二段的always(组合部分，赋值用=)里面判断条件一定要包含所有情况！可以用else保证包含完全。
6第二段always中，组合逻辑电平要维持超过一个clock，仿真时注意。
