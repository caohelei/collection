深入理解指针之必看

华清远见北京中心  华清远见北京中心  10月25日

一。指针的概念
    指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。
    要搞清一个指针需要搞清指针的四方面的内容：指针的类型，指针所指向的类型，指针的值或者叫指针所指向的内存区，还有指针本身所占据的内存区。

1。 指针的类型
    从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：
(1)int *ptr; //指针的类型是int *
(2)char *ptr; //指针的类型是char *
(3)int **ptr; //指针的类型是 int **
(4)int (*ptr)[3]; //指针的类型是 int(*)[3]
(5)int *(*ptr)[4]; //指针的类型是 int *(*)[4]
怎么样？找出指针的类型的方法是不是很简单？

2。指针所指向的类型
        从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符 *去掉，剩下的就是指针所指向的类型。例如：
(1)int *ptr; //指针所指向的类型是int
(2)char *ptr; //指针所指向的的类型是char
(3)int **ptr; //指针所指向的的类型是 int *
(4)int (*ptr)[3]; //指针所指向的的类型是 int()[3]
(5)int *(*ptr)[4]; //指针所指向的的类型是 int *()[4]
    在指针的算术运算中，指针所指向的类型有很大的作用。
    指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C越来越熟悉时，你会发现，把与指针搅和在一起的“类型”这个概念分成“指针的类 型”和“指针所指向的类型”两个概念，是精通指针的关键点之一。指针存储的是一个地址，这个地址是某一块内存的地址，这个地址里放的一定是一个数据，这个数据是有类型的，我们所知，int型占四个字节，char就占一个字节等等，当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。int型就取四个字节，char就取一个字节，这个在做指针运算时，非常重要，需要特别注意。

3。 指针的值
    指针的值，或者叫指针所指向的内存区或地址。 指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。
    指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就 相当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。
    指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。
    以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指向的类型是什么？该指针指向了哪里？
4。 指针本身所占据的内存区。
    指针本身占了多大的内存？你只要用sizeof(指针的类型)测一下就知道了。在32位平台里，指针本身占据了4个字节的长度。
    指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。

二。指针的算术运算
    指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。例如：
例二：              
  

  1 #include <stdio.h>
  2 int main()
  3 {
  4     int *p,i;
  5     char *q;
  6     int a[20] = {1,2,4,2,5};
  7     char b[20] = {'a','b','c','d','s','h'};
  8 
  9     p = a;
 10     q = b;
 11 
 12     printf("%d\n",sizeof(char *));
 13 
 14     for( i = 0; i < 5;i++ )
 15     {
 16 
 17         printf("%d\n",*(p++));
 18     }
 19 
 20     for( i = 0; i < 2; i++ )
 21     {
 22         printf("%c\n",*(q++));
 23 
 24     }
 25 
 26     for( i = 0; i < 2; i++)
 27     {
 28         printf("%p\n",q++);
 29 
 30     }
 31 
 32     return 0;
 33 
 34 }
    在上例中，指针p的类型是int*,它指向的类型是int，它被初始化为指向整形数组a。接下来指针p被加了1，编译器是这样处理 的：它把指针p的值加上了sizeof(int)，在32位程序中，是被加上了4。由于地址是用字节做 单位的，故p所指向的地址由原来的变量a的地址向高地址方向增加了4个字节。由于int类型的长度是四个字节，所以，原来p是指向数组a的第0 号单元开始的四个字节，此时指向了数组a中从第一个元素。同理，指针q加1，q所指向的地址向高地址增加了1个字节，数组b的每一个元素是char类型的，占1个字节，所以此时指向了数组的下一个元素。第三个for循环，实际上就是q所指向的地址加上sizeof（char），输出的是数组b首地址加1.“printf("%d\n",sizeof(char *));”输出的是指针本身所占的大小，指针本身占据了4个字节的长度。
